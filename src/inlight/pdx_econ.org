* Namespace and DB Connection
#+begin_src clojure :session PDX_ECON
  (ns inlight.core
    (:require [incanter.core :as i]
              [incanter.excel :as ixl]
              [next.jdbc :as jdbc]
              [next.jdbc.result-set :as jdbcrs]
              [sqlingvo.core :as sql]
              [clojure.string :as str]
              [clojure.pprint :as pp])
    (:import java.sql.DriverManager))

  ;; Create H2 DB.
  (def db-cred {:dbtype "postgresql"
                :dbname "ECON"
                :host "127.0.0.1"
                :post "5432"
                :user "postgres"
                :password "ela8teD53"})

  (def db (jdbc/get-datasource db-cred))

  (def dbsql (sql/db :postgresql))
#+end_src

#+RESULTS:
: nil#'inlight.core/db-cred#'inlight.core/db#'inlight.core/dbsql
* Table creation--PDX Employment Wage & Salary Data
#+begin_src clojure :session PDX_ECON
  ;; REPL -- Import table of Portland Employment Wage & Salary Data
  (def table-pdx-earn (ixl/read-xls "../inlight/resources/public/portland-emphrsearn-all-transposed.xlsx"))

  ;; Convert column names to uppercase and keywords, zipping with data values.
  (def table-pdx-earn-maps
    (for [mx (i/matrix table-pdx-earn)]
      (zipmap (map keyword
                   (map str/upper-case
                        (map #(str/replace % "-" "_") (i/col-names table-pdx-earn))))
              mx)))
  ;; (take 2 table-pdx-earn-maps)

  ;; Convert Jave Date to String for table upload.
  (defn date-to-string [date] (.format (java.text.SimpleDateFormat. "MM/dd/YYY") date))
  (def table-pdx-earn-maps-strdate
    (map #(update-in % [:MONTH] date-to-string) table-pdx-earn-maps))

  ;; Create earnings_portland table
  (jdbc/execute! db ["DROP TABLE IF EXISTS pdx_econ.earnings_portland;"])
  (def create-table-earnings-portland
    (sql/sql
     (sql/create-table dbsql :pdx_econ.earnings_portland
                       (sql/column :MONTH :varchar :size 25)
                       (sql/column :MANUFACTURING :float :size 25)
                       (sql/column :CONSTRUCTION :float :size 25)
                       (sql/column :LEISURE_HOSPITALITY :float :size 25)
                       (sql/column :FINANCIAL :float :size 25)
                       (sql/column :TRADE_TRANSPORT_UTILITY :float :size 25)
                       (sql/column :SERVICES_EDUCATION_HEALTH :float :size 25)
                       (sql/column :INFORMATION :float :size 25)
                       (sql/column :SERVICES_PROFESSIONAL_BUSINESS :float :size 25)
                       (sql/column :GOVERNMENT :float :size 25)
                       (sql/column :OTHER :float :size 25))))

  (jdbc/execute! db create-table-earnings-portland)

  (def insert-table-earnings-portland
  (sql/sql
    (sql/insert dbsql :pdx_econ.earnings_portland []
    (sql/values table-pdx-earn-maps-strdate))))

  (jdbc/execute! db insert-table-earnings-portland)

#+end_src

#+RESULTS:
: #'inlight.core/table-pdx-earn#'inlight.core/table-pdx-earn-maps[#:next.jdbc{:update-count 0}]#'inlight.core/create-table-earnings-portland[#:next.jdbc{:update-count 0}]#'inlight.core/insert-table-earnings-portland[#:next.jdbc{:update-count 129}]
* Table creation--PDX Unemployment
#+begin_src clojure :session PDX_ECON
  ;; REPL -- Import table of Portland Employment
  (def table-pdx-emp (ixl/read-xls "../inlight/resources/public/portland-employment.xlsx"))

  (def table-pdx-emp-maps
    (for [mx (i/matrix table-pdx-emp)]
      (zipmap (map keyword
                   (map str/upper-case
                        (map #(str/replace % "-" "_") (i/col-names table-pdx-emp))))
              mx)))

  ;; Change MONTH to string for table upload.
  (def table-pdx-emp-maps-strdate
    (map #(update-in % [:MONTH] date-to-string) table-pdx-emp-maps))


  ;; Create employment_portland table
  (jdbc/execute! db ["DROP TABLE IF EXISTS pdx_econ.employment_portland;"])
  (def create-table-employment-portland
    (sql/sql
     (sql/create-table dbsql :pdx_econ.employment_portland
                       (sql/column :MONTH :varchar :size 25)
                       (sql/column :LABOR_FORCE :float :size 25)
                       (sql/column :EMPLOYMENT :float :size 25)
                       (sql/column :UNEMPLOYMENT :float :size 25)
                       (sql/column :UNEMPLOYMENT_RATE :float :size 25)
                       )))


  (jdbc/execute! db create-table-employment-portland)

  (def insert-table-employment-portland
  (sql/sql
    (sql/insert dbsql :pdx_econ.employment_portland []
    (sql/values table-pdx-emp-maps-strdate))))

  (jdbc/execute! db insert-table-employment-portland)
#+end_src

#+RESULTS:
: #'inlight.core/table-pdx-emp#'inlight.core/table-pdx-emp-maps#'inlight.core/table-pdx-emp-maps-strdate[#:next.jdbc{:update-count 0}]#'inlight.core/create-table-employment-portland[#:next.jdbc{:update-count 0}]#'inlight.core/insert-table-employment-portland[#:next.jdbc{:update-count 129}]
* SQL
#+begin_src sql :session PDX_ECON
  DROP TABLE PDX_ECON.EARNINGS_EMPLOYMENT_JOIN IF EXISTS;
  CREATE MEMORY TABLE PDX_ECON.EARNINGS_EMPLOYMENT_JOIN as (
  SELECT ea.MONTH as PDX_MONTH, emp.UNEMPLOYMENT_RATE, ea.MANUFACTURING, ea.CONSTRUCTION, ea.LEISURE_HOSPITALITY, ea.FINANCIAL, ea.TRADE_TRANSPORT_UTILITY, ea.SERVICES_EDUCATION_HEALTH, ea.INFORMATION, ea.SERVICES_PROFESSIONAL_BUSINESS, ea.GOVERNMENT, ea.OTHER
  FROM PDX_ECON.EARNINGS_PORTLAND as ea
  LEFT JOIN PDX_ECON.EMPLOYMENT_PORTLAND as emp
  ON ea.MONTH = emp.MONTH
  ORDER BY ea.MONTH desc
  );
#+end_src

* Create Earnings Employment Join table with SQl
#+begin_src clojure :session PDX_ECON :results output
  ;; Run SQL Code from previous block
  (jdbc/execute! db ["DROP TABLE PDX_ECON.EARNINGS_EMPLOYMENT_JOIN IF EXISTS;
  CREATE MEMORY TABLE PDX_ECON.EARNINGS_EMPLOYMENT_JOIN as (
  SELECT ea.MONTH as PDX_MONTH, emp.UNEMPLOYMENT_RATE, ea.MANUFACTURING, ea.CONSTRUCTION, ea.LEISURE_HOSPITALITY, ea.FINANCIAL, ea.TRADE_TRANSPORT_UTILITY, ea.SERVICES_EDUCATION_HEALTH, ea.INFORMATION, ea.SERVICES_PROFESSIONAL_BUSINESS, ea.GOVERNMENT, ea.OTHER
  FROM PDX_ECON.EARNINGS_PORTLAND as ea
  LEFT JOIN PDX_ECON.EMPLOYMENT_PORTLAND as emp
  ON ea.MONTH = emp.MONTH
  ORDER BY ea.MONTH desc
  );
"])

  (pp/print-table (take 2 (jdbc/execute! db ["SELECT * FROM PDX_ECON.EARNINGS_EMPLOYMENT_JOIN;"]
                 {:return-keys true
                  :builder-fn jdbcrs/as-unqualified-lower-maps})))
#+end_src

#+RESULTS:
: 
: | :leisure_hospitality | :manufacturing | :unemployment_rate | :construction | :other | :services_education_health | :financial | :services_professional_business | :trade_transport_utility | :information | :pdx_month | :government |
: |----------------------+----------------+--------------------+---------------+--------+----------------------------+------------+---------------------------------+--------------------------+--------------+------------+-------------|
: |                 89.8 |          119.9 |                7.7 |          75.5 |   38.8 |                      174.3 |       70.6 |                           181.3 |                    212.1 |         24.6 | 2020-09-01 |       141.7 |
: |                 90.9 |          120.0 |                9.1 |          79.2 |   39.6 |                      169.3 |       70.0 |                           182.5 |                    210.8 |         24.4 | 2020-08-01 |       138.9 |

* SQL--Create YOY table
#+begin_src sql
DROP TABLE PDX_ECON.EARNINGS_EMPLOYMENT_12MO_LAG IF EXISTS;
CREATE MEMORY TABLE PDX_ECON.EARNINGS_EMPLOYMENT_12MO_LAG as (
SELECT PDX_MONTH, UNEMPLOYMENT_RATE, LAG(UNEMPLOYMENT_RATE, 12) OVER (ORDER BY PDX_MONTH) as UNEMPLOYMENT_RATE_12MO_LAG
FROM PDX_ECON.EARNINGS_EMPLOYMENT_JOIN
);

DROP TABLE PDX_ECON.EARNINGS_EMPLOYMENT_YOY_CHANGE IF EXISTS;
CREATE MEMORY TABLE PDX_ECON.EARNINGS_EMPLOYMENT_YOY_CHANGE as (
SELECT PDX_MONTH, UNEMPLOYMENT_RATE,
(((UNEMPLOYMENT_RATE - UNEMPLOYMENT_RATE_12MO_LAG)/UNEMPLOYMENT_RATE_12MO_LAG)*100) as UNEMPLOYMENT_RATE_YOY_CHANGE
FROM PDX_ECON.EARNINGS_EMPLOYMENT_12MO_LAG
);

#+end_src

* Create YOY table
#+begin_src clojure :results output
    ;; Run SQL Code from previous block
    (jdbc/execute! db ["
DROP TABLE PDX_ECON.EARNINGS_EMPLOYMENT_12MO_LAG IF EXISTS;
CREATE MEMORY TABLE PDX_ECON.EARNINGS_EMPLOYMENT_12MO_LAG as (
SELECT PDX_MONTH, UNEMPLOYMENT_RATE, LAG(UNEMPLOYMENT_RATE, 12) OVER (ORDER BY PDX_MONTH) as UNEMPLOYMENT_RATE_12MO_LAG
FROM PDX_ECON.EARNINGS_EMPLOYMENT_JOIN
);

DROP TABLE PDX_ECON.EARNINGS_EMPLOYMENT_YOY_CHANGE IF EXISTS;
CREATE MEMORY TABLE PDX_ECON.EARNINGS_EMPLOYMENT_YOY_CHANGE as (
SELECT PDX_MONTH, UNEMPLOYMENT_RATE,
(((UNEMPLOYMENT_RATE - UNEMPLOYMENT_RATE_12MO_LAG)/UNEMPLOYMENT_RATE_12MO_LAG)*100) as UNEMPLOYMENT_RATE_YOY_CHANGE
FROM PDX_ECON.EARNINGS_EMPLOYMENT_12MO_LAG
);
  "])

    (pp/print-table (take 15 (jdbc/execute! db ["SELECT * FROM PDX_ECON.EARNINGS_EMPLOYMENT_YOY_CHANGE;"]
                   {:return-keys true
                    :builder-fn jdbcrs/as-unqualified-lower-maps})))
#+end_src

#+RESULTS:
#+begin_example
class org.h2.jdbc.JdbcSQLNonTransientExceptionclass org.h2.jdbc.JdbcSQLNonTransientExceptionclass org.h2.jdbc.JdbcSQLNonTransientExceptionclass org.h2.jdbc.JdbcSQLNonTransientExceptionExecution error (JdbcSQLNonTransientException) at org.h2.message.DbException/getJdbcSQLException (DbException.java:505).
Unknown data type: "ROW"; SQL statement:
CREATE MEMORY TABLE "PDX_ECON"."EARNINGS_EMPLOYMENT_YOY_CHANGE"(
    "PDX_MONTH" DATE,
    "UNEMPLOYMENT_RATE" DOUBLE,
    "UNEMPLOYMENT_RATE_YOY_CHANGE" ROW
) [50004-200]
Execution error (JdbcSQLNonTransientException) at org.h2.message.DbException/getJdbcSQLException (DbException.java:505).
Unknown data type: "ROW"; SQL statement:
CREATE MEMORY TABLE "PDX_ECON"."EARNINGS_EMPLOYMENT_YOY_CHANGE"(
    "PDX_MONTH" DATE,
    "UNEMPLOYMENT_RATE" DOUBLE,
    "UNEMPLOYMENT_RATE_YOY_CHANGE" ROW
) [50004-200]
#+end_example
